diff --git a/configure.ac b/configure.ac
index 4f351c5..3430449 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1932,6 +1960,11 @@ esac
 # remember to convert commas to spaces
 for codecs in `echo $add_codecs | sed 's/,/ /g'`; do
   case $codecs in
+    *c1*)
+        AC_CHECK_HEADER([amcodec/codec.h],, AC_MSG_ERROR($missing_headers))
+	AC_CHECK_LIB([amcodec], main, LIBS="$LIBS -lamcodec -lamadec -lasound -lamavutils", AC_MSG_ERROR($missing_library))
+        XB_ADD_CODEC([C1], [c1], [$codecs])
+        ;;
     *amcodec*)
         AC_CHECK_HEADER([amcodec/codec_error.h],, AC_MSG_ERROR($missing_headers))
         XB_ADD_CODEC([LIBAMCODEC], [amcodec], [$codecs])
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp b/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
index 4c363cf..9196cb9 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
@@ -50,6 +50,9 @@
 #include "Video/DVDVideoCodecAndroidMediaCodec.h"
 #include "android/activity/AndroidFeatures.h"
 #endif
+#if defined(HAS_C1)
+#include "Video/DVDVideoCodecC1.h"
+#endif
 #include "Audio/DVDAudioCodecFFmpeg.h"
 #include "Audio/DVDAudioCodecPassthrough.h"
 #include "Overlay/DVDOverlayCodecSSA.h"
@@ -199,6 +205,11 @@ CDVDVideoCodec* CDVDFactoryCodec::CreateVideoCodec(CDVDStreamInfo &hint, const C
 #else
   hwSupport += "MMAL:no ";
 #endif
+#if defined(HAS_C1) && defined(_LINUX)
+  hwSupport += "C1:yes ";
+#elif defined(_LINUX)
+  hwSupport += "C1:no ";
+#endif
   CLog::Log(LOGDEBUG, "CDVDFactoryCodec: compiled in hardware support: %s", hwSupport.c_str());
 
   if (hint.stills && (hint.codec == AV_CODEC_ID_MPEG2VIDEO || hint.codec == AV_CODEC_ID_MPEG1VIDEO))
@@ -207,6 +223,14 @@ CDVDVideoCodec* CDVDFactoryCodec::CreateVideoCodec(CDVDStreamInfo &hint, const C
      if ( (pCodec = OpenCodec(new CDVDVideoCodecLibMpeg2(), hint, options)) ) return pCodec;
   }
 
+#if defined(HAS_C1)
+  if ( !hint.software )
+  {
+    if ( hint.codec == AV_CODEC_ID_MPEG1VIDEO || hint.codec == AV_CODEC_ID_MPEG2VIDEO || hint.codec == AV_CODEC_ID_MPEG4 || hint.codec == AV_CODEC_ID_H264 || hint.codec == AV_CODEC_ID_HEVC )
+      if( (pCodec = OpenCodec(new CDVDVideoCodecC1(), hint, options)) ) return pCodec;
+  }
+#endif
+
 #if defined(HAS_LIBAMCODEC)
   // amcodec can handle dvd playback.
   if (!hint.software && CSettings::Get().GetBool("videoplayer.useamcodec"))
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecFFmpeg.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecFFmpeg.cpp
index e7bed43..06f81c8 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecFFmpeg.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayCodecFFmpeg.cpp
@@ -243,6 +243,16 @@ CDVDOverlay* CDVDOverlayCodecFFmpeg::GetOverlay()
     m_height = m_pCodecContext->height;
     m_width  = m_pCodecContext->width;
 
+    // ETSI EN 300 743 V1.3.1
+    // 5.3.1
+    // Absence of a DDS in a stream implies that the stream is coded in accordance with EN 300 743 (V1.2.1) [5] and that a
+    // display width of 720 pixels and a display height of 576 lines may be assumed.
+    if (!m_height && !m_width)
+    {
+      m_width = 720;
+      m_height = 576;
+    }
+
     RENDER_STEREO_MODE render_stereo_mode = g_graphicsContext.GetStereoMode();
     if (render_stereo_mode != RENDER_STEREO_MODE_OFF)
     {
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/AMLCodec.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/AMLCodec.cpp
index 450b4a9..fa6f024 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/AMLCodec.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/AMLCodec.cpp
@@ -93,18 +93,12 @@ public:
   virtual int codec_set_cntl_avthresh(codec_para_t *pcodec, unsigned int avthresh)=0;
   virtual int codec_set_cntl_syncthresh(codec_para_t *pcodec, unsigned int syncthresh)=0;
 
-  // grab these from libamplayer
-  virtual int h263vld(unsigned char *inbuf, unsigned char *outbuf, int inbuf_len, int s263)=0;
-  virtual int decodeble_h263(unsigned char *buf)=0;
-
-  // grab this from amffmpeg so we do not have to load DllAvUtil
-  virtual AVRational av_d2q(double d, int max)=0;
 };
 
 class DllLibAmCodec : public DllDynamic, DllLibamCodecInterface
 {
   // libamcodec is static linked into libamplayer.so
-  DECLARE_DLL_WRAPPER(DllLibAmCodec, "libamplayer.so")
+  DECLARE_DLL_WRAPPER(DllLibAmCodec, "libamcodec.so")
 
   DEFINE_METHOD1(int, codec_init,               (codec_para_t *p1))
   DEFINE_METHOD1(int, codec_close,              (codec_para_t *p1))
@@ -122,11 +116,6 @@ class DllLibAmCodec : public DllDynamic, DllLibamCodecInterface
   DEFINE_METHOD2(int, codec_set_cntl_avthresh,  (codec_para_t *p1, unsigned int p2))
   DEFINE_METHOD2(int, codec_set_cntl_syncthresh,(codec_para_t *p1, unsigned int p2))
 
-  DEFINE_METHOD4(int, h263vld,                  (unsigned char *p1, unsigned char *p2, int p3, int p4))
-  DEFINE_METHOD1(int, decodeble_h263,           (unsigned char *p1))
-
-  DEFINE_METHOD2(AVRational, av_d2q,            (double p1, int p2))
-
   BEGIN_METHOD_RESOLVE()
     RESOLVE_METHOD(codec_init)
     RESOLVE_METHOD(codec_close)
@@ -144,10 +133,6 @@ class DllLibAmCodec : public DllDynamic, DllLibamCodecInterface
     RESOLVE_METHOD(codec_set_cntl_avthresh)
     RESOLVE_METHOD(codec_set_cntl_syncthresh)
 
-    RESOLVE_METHOD(h263vld)
-    RESOLVE_METHOD(decodeble_h263)
-
-    RESOLVE_METHOD(av_d2q)
   END_METHOD_RESOLVE()
 
 public:
@@ -372,7 +357,7 @@ void dumpfile_write(am_private_t *para, void* buf, int bufsiz)
   }
 
   if (para->dumpdemux && para->dumpfile != -1)
-    write(para->dumpfile, buf, bufsiz);
+    int ret = write(para->dumpfile, buf, bufsiz);
 }
 
 /*************************************************************************/
@@ -404,7 +389,7 @@ static int set_pts_pcrscr(int64_t value)
     char pts_str[64];
     unsigned long pts = (unsigned long)value;
     sprintf(pts_str, "0x%lx", pts);
-    write(fd, pts_str, strlen(pts_str));
+    int ret = write(fd, pts_str, strlen(pts_str));
     close(fd);
     return 0;
   }
@@ -725,7 +710,7 @@ int write_av_packet(am_private_t *para, am_packet_t *pkt)
         }
         pkt->newflag = 0;
     }
-	
+
     buf = pkt->data;
     size = pkt->data_size ;
     if (size == 0 && pkt->isvalid) {
@@ -1247,51 +1232,6 @@ int set_header_info(am_private_t *para)
       {
         return divx3_prefix(pkt);
       }
-      else if (para->video_codec_type == VIDEO_DEC_FORMAT_H263)
-      {
-        return PLAYER_UNSUPPORT;
-        unsigned char *vld_buf;
-        int vld_len, vld_buf_size = para->video_width * para->video_height * 2;
-
-        if (!pkt->data_size) {
-            return PLAYER_SUCCESS;
-        }
-
-        if ((pkt->data[0] == 0) && (pkt->data[1] == 0) && (pkt->data[2] == 1) && (pkt->data[3] == 0xb6)) {
-            return PLAYER_SUCCESS;
-        }
-
-        vld_buf = (unsigned char*)malloc(vld_buf_size);
-        if (!vld_buf) {
-            return PLAYER_NOMEM;
-        }
-
-        if (para->flv_flag) {
-            vld_len = para->m_dll->h263vld(pkt->data, vld_buf, pkt->data_size, 1);
-        } else {
-            if (0 == para->h263_decodable) {
-                para->h263_decodable = para->m_dll->decodeble_h263(pkt->data);
-                if (0 == para->h263_decodable) {
-                    CLog::Log(LOGDEBUG, "[%s]h263 unsupport video and audio, exit", __FUNCTION__);
-                    return PLAYER_UNSUPPORT;
-                }
-            }
-            vld_len = para->m_dll->h263vld(pkt->data, vld_buf, pkt->data_size, 0);
-        }
-
-        if (vld_len > 0) {
-            if (pkt->buf) {
-                free(pkt->buf);
-            }
-            pkt->buf = vld_buf;
-            pkt->buf_size = vld_buf_size;
-            pkt->data = pkt->buf;
-            pkt->data_size = vld_len;
-        } else {
-            free(vld_buf);
-            pkt->data_size = 0;
-        }
-      }
     } else if (para->video_format == VFORMAT_VC1) {
         if (para->video_codec_type == VIDEO_DEC_FORMAT_WMV3) {
             unsigned i, check_sum = 0, data_len = 0;
@@ -1484,7 +1424,7 @@ bool CAMLCodec::OpenDecoder(CDVDStreamInfo &hints)
   am_private->video_pid        = hints.pid;
 
   // handle video ratio
-  AVRational video_ratio       = m_dll->av_d2q(1, SHRT_MAX);
+  AVRational video_ratio       = av_d2q(1, SHRT_MAX);
   //if (!hints.forced_aspect)
   //  video_ratio = m_dll->av_d2q(hints.aspect, SHRT_MAX);
   am_private->video_ratio      = ((int32_t)video_ratio.num << 16) | video_ratio.den;
@@ -1612,7 +1552,7 @@ bool CAMLCodec::OpenDecoder(CDVDStreamInfo &hints)
       // h264 in an avi file
       if (m_hints.ptsinvalid)
         am_private->gcodec.param = (void*)(EXTERNAL_PTS | SYNC_OUTSIDE);
-      break; 
+      break;
     case VFORMAT_REAL:
       am_private->stream_type = AM_STREAM_RM;
       am_private->vcodec.noblock = 1;
@@ -2030,20 +1972,16 @@ void CAMLCodec::Process()
 
         double error = app_pts - (double)pts_video/PTS_FREQ;
         double abs_error = fabs(error);
-        if (abs_error > 0.125)
+        if (abs_error > 0.150)
         {
-          //CLog::Log(LOGDEBUG, "CAMLCodec::Process pts diff = %f", error);
-          if (abs_error > 0.150)
-          {
-            // big error so try to reset pts_pcrscr
-            SetVideoPtsSeconds(app_pts);
-          }
-          else
-          {
-            // small error so try to avoid a frame jump
-            SetVideoPtsSeconds((double)pts_video/PTS_FREQ + error/4);
-          }
+          // big error so try to reset pts_pcrscr
+          SetVideoPtsSeconds(app_pts);
         }
+        else
+        {
+          // small error so try to avoid a frame jump
+          SetVideoPtsSeconds((double)pts_video/PTS_FREQ + error/4);
+        }        
       }
     }
     else
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecC1.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecC1.cpp
new file mode 100644
index 0000000..3ce53f5
--- /dev/null
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecC1.cpp
@@ -0,0 +1,175 @@
+#include "system.h"
+
+#ifndef THIS_IS_NOT_XBMC
+  #if (defined HAVE_CONFIG_H) && (!defined WIN32)
+    #include "config.h"
+  #endif
+  #include "DVDClock.h"
+  #include "DVDStreamInfo.h"
+  #include "AMLCodec.h"
+  #include "utils/AMLUtils.h"
+  #include "utils/BitstreamConverter.h"
+  #include "utils/log.h"
+#endif
+
+#include "DVDVideoCodecC1.h"
+
+#include <math.h>
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <poll.h>
+#include <sys/mman.h>
+#include <dirent.h>
+
+#ifdef CLASSNAME
+#undef CLASSNAME
+#endif
+#define CLASSNAME "CDVDVideoCodecC1"
+
+CDVDVideoCodecC1::CDVDVideoCodecC1() :
+  m_Codec(NULL),
+  m_pFormatName("c1-none")
+{
+  m_bitstream = new CBitstreamConverter;
+  memzero(m_videobuffer);
+}
+
+CDVDVideoCodecC1::~CDVDVideoCodecC1()
+{
+  Dispose();
+  if (m_bitstream)
+    delete m_bitstream, m_bitstream = NULL;
+}
+
+bool CDVDVideoCodecC1::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
+{
+  m_hints = hints;
+  if (m_hints.software)
+    return false;
+
+  if (!aml_permissions())
+  {
+    CLog::Log(LOGERROR, "AML: no proper permission, please contact the device vendor. Skipping codec...");
+    return false;
+  }
+
+  switch(m_hints.codec)
+  {
+    case AV_CODEC_ID_MPEG1VIDEO:
+    case AV_CODEC_ID_MPEG2VIDEO:
+      m_pFormatName = "c1-mpeg2";
+      break;
+    case AV_CODEC_ID_MPEG4:
+    case AV_CODEC_ID_MSMPEG4V2:
+    case AV_CODEC_ID_MSMPEG4V3:
+      m_pFormatName = "c1-mpeg4";
+      break;
+    case AV_CODEC_ID_H264:
+      m_pFormatName = "c1-h264";
+      break;
+    case AV_CODEC_ID_HEVC:
+      m_pFormatName = "c1-hevc";
+      break;
+    default:
+      CLog::Log(LOGDEBUG, "%s: Unknown hints.codec id: %d", CLASSNAME, m_hints.codec);
+      return false;
+      break;
+  }
+
+  m_bVideoConvert = m_bitstream->Open(m_hints.codec, (uint8_t*)m_hints.extradata, m_hints.extrasize, true);
+  if (m_bVideoConvert) {
+    m_hints.extrasize = m_bitstream->GetExtraSize();
+    free(m_hints.extradata);
+    m_hints.extradata = malloc(m_hints.extrasize);
+    memcpy(m_hints.extradata, m_bitstream->GetExtraData(), m_hints.extrasize);
+  }
+
+  m_Codec = new CLinuxC1Codec();
+  if (!m_Codec)
+  {
+    CLog::Log(LOGERROR, "%s: Failed to create C1 Amlogic Codec", CLASSNAME);
+    return false;
+  }
+
+  if (!m_Codec->OpenDecoder(m_hints)) {
+    CLog::Log(LOGERROR, "%s: Failed to open C1 Amlogic Codec", CLASSNAME);
+    return false;
+  }
+
+  memzero(m_videobuffer);
+
+  m_videobuffer.dts             = DVD_NOPTS_VALUE;
+  m_videobuffer.pts             = DVD_NOPTS_VALUE;
+  m_videobuffer.format          = RENDER_FMT_BYPASS;
+  m_videobuffer.color_range     = 0;
+  m_videobuffer.color_matrix    = 4;
+  m_videobuffer.iFlags          = DVP_FLAG_ALLOCATED;
+  m_videobuffer.iWidth          = m_hints.width;
+  m_videobuffer.iHeight         = m_hints.height;
+  m_videobuffer.iDisplayWidth   = m_videobuffer.iWidth;
+  m_videobuffer.iDisplayHeight  = m_videobuffer.iHeight;
+
+  if (m_hints.aspect > 0.0 && (((uint)lrint(m_videobuffer.iHeight * m_hints.aspect)) & -3) > m_videobuffer.iWidth)
+      m_videobuffer.iDisplayWidth = ((int)lrint(m_videobuffer.iHeight * m_hints.aspect)) & -3;
+  double scale = fmin(
+    (double)CDisplaySettings::Get().GetCurrentResolutionInfo().iWidth / (double)m_videobuffer.iDisplayWidth,
+    (double)CDisplaySettings::Get().GetCurrentResolutionInfo().iHeight / (double)m_videobuffer.iDisplayHeight
+  );
+  m_videobuffer.iDisplayWidth = (int)((double)m_videobuffer.iDisplayWidth * scale);
+  m_videobuffer.iDisplayHeight  = (int)((double)m_videobuffer.iDisplayHeight * scale);
+
+  CLog::Log(LOGNOTICE, "%s::%s Opened C1 Amlogic Codec. DisplayWidth: %d, DisplayHeight: %d", CLASSNAME, __func__, m_videobuffer.iDisplayWidth, m_videobuffer.iDisplayHeight);
+  return true;
+}
+
+void CDVDVideoCodecC1::Dispose(void)
+{
+  if (m_Codec)
+    m_Codec->CloseDecoder(), delete m_Codec, m_Codec = NULL;
+  if (m_videobuffer.iFlags)
+    m_videobuffer.iFlags = 0;
+}
+
+int CDVDVideoCodecC1::Decode(uint8_t *pData, int iSize, double dts, double pts)
+{
+
+  if (m_hints.ptsinvalid)
+    pts = DVD_NOPTS_VALUE;
+
+  if (pData)
+  {
+    if (m_bVideoConvert) {
+      m_bitstream->Convert(pData, iSize);
+      pData = m_bitstream->GetConvertBuffer();
+      iSize = m_bitstream->GetConvertSize();
+    }
+  }
+
+  return m_Codec->Decode(pData, iSize, dts, pts);
+}
+
+void CDVDVideoCodecC1::Reset(void)
+{
+  m_Codec->Reset();
+}
+
+bool CDVDVideoCodecC1::GetPicture(DVDVideoPicture* pDvdVideoPicture)
+{
+  m_Codec->GetPicture(&m_videobuffer);
+  *pDvdVideoPicture = m_videobuffer;
+
+  return true;
+}
+
+void CDVDVideoCodecC1::SetDropState(bool bDrop)
+{
+}
+
+void CDVDVideoCodecC1::SetSpeed(int iSpeed)
+{
+  if (m_Codec)
+    m_Codec->SetSpeed(iSpeed);
+}
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecC1.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecC1.h
new file mode 100644
index 0000000..925434a
--- /dev/null
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecC1.h
@@ -0,0 +1,44 @@
+#pragma once
+
+#ifndef THIS_IS_NOT_XBMC
+  #include "DVDVideoCodec.h"
+  #include "DVDStreamInfo.h"
+  #include "utils/BitstreamConverter.h"
+  #include "LinuxC1Codec.h"
+#else
+  #include "xbmcstubs.h"
+  #include "LinuxC1Codec.h"
+#endif
+
+typedef struct frame_queue {
+  double dts;
+  double pts;
+  double sort_time;
+  struct frame_queue *nextframe;
+} frame_queue;
+
+class CDVDVideoCodecC1 : public CDVDVideoCodec
+{
+public:
+  CDVDVideoCodecC1();
+  virtual ~CDVDVideoCodecC1();
+
+  // Required overrides
+  virtual bool Open(CDVDStreamInfo &hints, CDVDCodecOptions &options);
+  virtual void Dispose(void);
+  virtual int  Decode(uint8_t *pData, int iSize, double dts, double pts);
+  virtual void Reset(void);
+  virtual bool GetPicture(DVDVideoPicture *pDvdVideoPicture);
+  virtual void SetSpeed(int iSpeed);
+  virtual void SetDropState(bool bDrop);
+  virtual const char* GetName(void) { return (const char*)m_pFormatName; }
+
+protected:
+  CLinuxC1Codec  *m_Codec;
+  const char     *m_pFormatName;
+  DVDVideoPicture m_videobuffer;
+  CDVDStreamInfo  m_hints;
+
+  CBitstreamConverter *m_bitstream;
+  bool                 m_bVideoConvert;
+};
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/LinuxC1Codec.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/LinuxC1Codec.cpp
new file mode 100644
index 0000000..b5157ea
--- /dev/null
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/LinuxC1Codec.cpp
@@ -0,0 +1,913 @@
+#include "system.h"
+
+#ifndef THIS_IS_NOT_XBMC
+  #if (defined HAVE_CONFIG_H) && (!defined WIN32)
+    #include "config.h"
+  #endif
+
+  #include "utils/log.h"
+#endif
+
+#include "LinuxC1Codec.h"
+
+#ifdef CLASSNAME
+#undef CLASSNAME
+#endif
+#define CLASSNAME "CLinuxC1Codec"
+
+static int64_t get_pts_video()
+{
+  int fd = open("/sys/class/tsync/pts_video", O_RDONLY);
+  if (fd >= 0)
+  {
+    char pts_str[16];
+    int size = read(fd, pts_str, sizeof(pts_str));
+    close(fd);
+    if (size > 0)
+    {
+      unsigned long pts = strtoul(pts_str, NULL, 16);
+      debug_log(LOGDEBUG, "%s::%s get_pts_video: %lu", CLASSNAME, __func__, pts);
+      return pts;
+    }
+  }
+  CLog::Log(LOGERROR, "%s::%s get_pts_video: open /tsync/event error", CLASSNAME, __func__);
+  return -1;
+}
+
+static vformat_t codecid_to_vformat(enum AVCodecID id)
+{
+  vformat_t format;
+  switch (id)
+  {
+    case AV_CODEC_ID_MPEG1VIDEO:
+    case AV_CODEC_ID_MPEG2VIDEO:
+      format = VFORMAT_MPEG12;
+      break;
+    case AV_CODEC_ID_MPEG4:
+      format = VFORMAT_MPEG4;
+      break;
+    case AV_CODEC_ID_H264:
+      format = VFORMAT_H264;
+      break;
+    case AV_CODEC_ID_HEVC:
+      format = VFORMAT_HEVC;
+      break;
+    default:
+      format = VFORMAT_UNSUPPORT;
+      break;
+  }
+
+  CLog::Log(LOGDEBUG, "%s::%s codecid_to_vformat, id(%d) -> vformat(%d)", CLASSNAME, __func__, (int)id, format);
+  return format;
+}
+
+static vdec_type_t codec_tag_to_vdec_type(unsigned int codec_tag)
+{
+  vdec_type_t dec_type;
+  switch (codec_tag)
+  {
+    case CODEC_TAG_COL1:
+    case CODEC_TAG_DIV3:
+    case CODEC_TAG_MP43:
+      // divx3.11
+      dec_type = VIDEO_DEC_FORMAT_MPEG4_3;
+      break;
+    case CODEC_TAG_DIV4:
+    case CODEC_TAG_DIVX:
+      // divx4
+      dec_type = VIDEO_DEC_FORMAT_MPEG4_4;
+      break;
+    case CODEC_TAG_XVID:
+    case CODEC_TAG_xvid:
+    case CODEC_TAG_XVIX:
+    case CODEC_TAG_DIV5:
+    case CODEC_TAG_DX50:
+    case CODEC_TAG_M4S2:
+    case CODEC_TAG_FMP4:
+    case CODEC_TAG_DIV6:
+    case CODEC_TAG_MP4V:
+    case CODEC_TAG_RMP4:
+    case CODEC_TAG_MPG4:
+    case CODEC_TAG_mp4v:
+    case AV_CODEC_ID_MPEG4:
+      dec_type = VIDEO_DEC_FORMAT_MPEG4_5;
+      break;
+    case CODEC_TAG_AVC1:
+    case CODEC_TAG_avc1:
+    case CODEC_TAG_H264:
+    case CODEC_TAG_h264:
+    case AV_CODEC_ID_H264:
+      dec_type = VIDEO_DEC_FORMAT_H264;
+      break;
+    case AV_CODEC_ID_HEVC:
+      dec_type = VIDEO_DEC_FORMAT_HEVC;
+      break;
+
+    default:
+      dec_type = VIDEO_DEC_FORMAT_UNKNOW;
+      break;
+  }
+
+  CLog::Log(LOGDEBUG, "%s::%s codec_tag_to_vdec_type, codec_tag(%d) -> vdec_type(%d)", CLASSNAME, __func__, codec_tag, dec_type);
+  return dec_type;
+}
+
+void codec_init_para(aml_generic_param *p_in, codec_para_t *p_out)
+{
+  memzero(*p_out);
+
+  p_out->has_video          = 1;
+  p_out->noblock            = p_in->noblock;
+  p_out->video_pid          = p_in->video_pid;
+  p_out->video_type         = p_in->video_type;
+  p_out->stream_type        = p_in->stream_type;
+  p_out->am_sysinfo.format  = p_in->format;
+  p_out->am_sysinfo.width   = p_in->width;
+  p_out->am_sysinfo.height  = p_in->height;
+  p_out->am_sysinfo.rate    = p_in->rate;
+  p_out->am_sysinfo.extra   = p_in->extra;
+  p_out->am_sysinfo.status  = p_in->status;
+  p_out->am_sysinfo.ratio   = p_in->ratio;
+  p_out->am_sysinfo.ratio64 = p_in->ratio64;
+  p_out->am_sysinfo.param   = p_in->param;
+}
+
+void am_packet_release(am_packet_t *pkt)
+{
+  if (pkt->buf != NULL)
+    free(pkt->buf), pkt->buf= NULL;
+  if (pkt->hdr != NULL)
+  {
+    if (pkt->hdr->data != NULL)
+      free(pkt->hdr->data), pkt->hdr->data = NULL;
+    free(pkt->hdr), pkt->hdr = NULL;
+  }
+
+  pkt->codec = NULL;
+}
+
+int check_in_pts(am_private_t *para, am_packet_t *pkt)
+{
+    int last_duration = 0;
+    static int last_v_duration = 0;
+    int64_t pts = 0;
+
+    last_duration = last_v_duration;
+
+    if (para->stream_type == AM_STREAM_ES) {
+        if ((int64_t)AV_NOPTS_VALUE != pkt->avpts) {
+            pts = pkt->avpts;
+
+            if (codec_checkin_pts(pkt->codec, pts) != 0) {
+                CLog::Log(LOGERROR, "%s::%s ERROR check in pts error!", CLASSNAME, __func__);
+                return PLAYER_PTS_ERROR;
+            }
+
+        } else if ((int64_t)AV_NOPTS_VALUE != pkt->avdts) {
+            pts = pkt->avdts * last_duration;
+
+            if (codec_checkin_pts(pkt->codec, pts) != 0) {
+                CLog::Log(LOGERROR, "%s::%s ERROR check in dts error!", CLASSNAME, __func__);
+                return PLAYER_PTS_ERROR;
+            }
+
+            last_v_duration = pkt->avduration ? pkt->avduration : 1;
+        } else {
+            if (!para->check_first_pts) {
+                if (codec_checkin_pts(pkt->codec, 0) != 0) {
+                    CLog::Log(LOGERROR, "%s::%s ERROR check in 0 to video pts error!", CLASSNAME, __func__);
+                    return PLAYER_PTS_ERROR;
+                }
+            }
+        }
+        if (!para->check_first_pts) {
+            para->check_first_pts = 1;
+        }
+    }
+    if (pts > 0)
+      pkt->lastpts = pts;
+
+    return PLAYER_SUCCESS;
+}
+
+static int write_header(am_private_t *para, am_packet_t *pkt)
+{
+    int write_bytes = 0, len = 0;
+
+    if (pkt->hdr && pkt->hdr->size > 0) {
+        if ((NULL == pkt->codec) || (NULL == pkt->hdr->data)) {
+            CLog::Log(LOGERROR, "%s::%s [write_header]codec null!", CLASSNAME, __func__);
+            return PLAYER_EMPTY_P;
+        }
+        while (1) {
+            write_bytes = codec_write(pkt->codec, pkt->hdr->data + len, pkt->hdr->size - len);
+            if (write_bytes < 0 || write_bytes > (pkt->hdr->size - len)) {
+                if (-errno != AVERROR(EAGAIN)) {
+                    CLog::Log(LOGERROR, "%s::%s ERROR:write header failed!", CLASSNAME, __func__);
+                    return PLAYER_WR_FAILED;
+                } else {
+                    continue;
+                }
+            } else {
+                len += write_bytes;
+                if (len == pkt->hdr->size) {
+                    break;
+                }
+            }
+        }
+    }
+    return PLAYER_SUCCESS;
+}
+
+int write_av_packet(am_private_t *para, am_packet_t *pkt)
+{
+  //CLog::Log(LOGDEBUG, "write_av_packet, pkt->isvalid(%d), pkt->data(%p), pkt->data_size(%d)",
+  //  pkt->isvalid, pkt->data, pkt->data_size);
+
+    int write_bytes = 0, len = 0, ret;
+    unsigned char *buf;
+    int size;
+
+    // do we need to check in pts or write the header ?
+    if (pkt->newflag) {
+        if (pkt->isvalid) {
+            ret = check_in_pts(para, pkt);
+            if (ret != PLAYER_SUCCESS) {
+                CLog::Log(LOGERROR, "%s::%s check in pts failed", CLASSNAME, __func__);
+                return PLAYER_WR_FAILED;
+            }
+        }
+        if (write_header(para, pkt) == PLAYER_WR_FAILED) {
+            CLog::Log(LOGERROR, "%s::%s write header failed!", CLASSNAME, __func__);
+            return PLAYER_WR_FAILED;
+        }
+        pkt->newflag = 0;
+    }
+
+    buf = pkt->data;
+    size = pkt->data_size ;
+    if (size == 0 && pkt->isvalid) {
+        pkt->isvalid = 0;
+        pkt->data_size = 0;
+    }
+
+    while (size > 0 && pkt->isvalid) {
+        write_bytes = codec_write(pkt->codec, buf, size);
+        if (write_bytes < 0 || write_bytes > size) {
+            CLog::Log(LOGDEBUG, "%s::%s write codec data failed, write_bytes(%d), errno(%d), size(%d)", CLASSNAME, __func__, write_bytes, errno, size);
+            if (-errno != AVERROR(EAGAIN)) {
+                CLog::Log(LOGDEBUG, "write codec data failed!");
+                return PLAYER_WR_FAILED;
+            } else {
+                // adjust for any data we already wrote into codec.
+                // we sleep a bit then exit as we will get called again
+                // with the same pkt because pkt->isvalid has not been cleared.
+                pkt->data += len;
+                pkt->data_size -= len;
+                usleep(RW_WAIT_TIME);
+                CLog::Log(LOGDEBUG, "%s::%s usleep(RW_WAIT_TIME), len(%d)", CLASSNAME, __func__, len);
+                return PLAYER_SUCCESS;
+            }
+        } else {
+            // keep track of what we write into codec from this pkt
+            // in case we get hit with EAGAIN.
+            len += write_bytes;
+            if (len == pkt->data_size) {
+                pkt->isvalid = 0;
+                pkt->data_size = 0;
+                break;
+            } else if (len < pkt->data_size) {
+                buf += write_bytes;
+                size -= write_bytes;
+            } else {
+                // writing more that we should is a failure.
+                return PLAYER_WR_FAILED;
+            }
+        }
+    }
+
+    return PLAYER_SUCCESS;
+}
+
+static int h264_add_header(unsigned char *buf, int size, am_packet_t *pkt)
+{
+    if (size > HDR_BUF_SIZE)
+    {
+        free(pkt->hdr->data);
+        pkt->hdr->data = (char *)malloc(size);
+        if (!pkt->hdr->data)
+            return PLAYER_NOMEM;
+    }
+
+    memcpy(pkt->hdr->data, buf, size);
+    pkt->hdr->size = size;
+    return PLAYER_SUCCESS;
+}
+
+static int h264_write_header(am_private_t *para, am_packet_t *pkt)
+{
+    CLog::Log(LOGDEBUG, "%s::%s h264_write_header", CLASSNAME, __func__);
+
+    int ret = h264_add_header(para->extradata, para->extrasize, pkt);
+    if (ret == PLAYER_SUCCESS) {
+        pkt->codec = &para->vcodec;
+        pkt->newflag = 1;
+        ret = write_av_packet(para, pkt);
+    }
+    return ret;
+}
+
+static int hevc_add_header(unsigned char *buf, int size,  am_packet_t *pkt)
+{
+    if (size > HDR_BUF_SIZE)
+    {
+        free(pkt->hdr->data);
+        pkt->hdr->data = (char *)malloc(size);
+        if (!pkt->hdr->data)
+            return PLAYER_NOMEM;
+    }
+
+    memcpy(pkt->hdr->data, buf, size);
+    pkt->hdr->size = size;
+    return PLAYER_SUCCESS;
+}
+
+static int hevc_write_header(am_private_t *para, am_packet_t *pkt)
+{
+    int ret = -1;
+
+    if (para->extradata) {
+      ret = hevc_add_header(para->extradata, para->extrasize, pkt);
+    }
+    if (ret == PLAYER_SUCCESS) {
+      pkt->codec = &para->vcodec;
+      pkt->newflag = 1;
+      ret = write_av_packet(para, pkt);
+    }
+    return ret;
+}
+
+static int divx3_data_prefeeding(am_packet_t *pkt, unsigned w, unsigned h)
+{
+    unsigned i = (w << 12) | (h & 0xfff);
+    unsigned char divx311_add[10] = {
+        0x00, 0x00, 0x00, 0x01,
+        0x20, 0x00, 0x00, 0x00,
+        0x00, 0x00
+    };
+    divx311_add[5] = (i >> 16) & 0xff;
+    divx311_add[6] = (i >> 8) & 0xff;
+    divx311_add[7] = i & 0xff;
+
+    if (pkt->hdr->data) {
+        memcpy(pkt->hdr->data, divx311_add, sizeof(divx311_add));
+        pkt->hdr->size = sizeof(divx311_add);
+    } else {
+        CLog::Log(LOGERROR, "%s::%s [divx3_data_prefeeding]No enough memory!", CLASSNAME, __func__);
+        return PLAYER_FAILED;
+    }
+    return PLAYER_SUCCESS;
+}
+
+static int divx3_write_header(am_private_t *para, am_packet_t *pkt)
+{
+    CLog::Log(LOGDEBUG, "%s::%s divx3_write_header", CLASSNAME, __func__);
+
+    divx3_data_prefeeding(pkt, para->video_width, para->video_height);
+
+    pkt->codec = &para->vcodec;
+    pkt->newflag = 1;
+    write_av_packet(para, pkt);
+    return PLAYER_SUCCESS;
+}
+
+static int m4s2_dx50_mp4v_add_header(unsigned char *buf, int size,  am_packet_t *pkt)
+{
+    if (size > pkt->hdr->size) {
+        free(pkt->hdr->data), pkt->hdr->data = NULL;
+        pkt->hdr->size = 0;
+
+        pkt->hdr->data = (char*)malloc(size);
+        if (!pkt->hdr->data) {
+            CLog::Log(LOGERROR, "%s::%s [m4s2_dx50_add_header] NOMEM!", CLASSNAME, __func__);
+            return PLAYER_FAILED;
+        }
+    }
+
+    pkt->hdr->size = size;
+    memcpy(pkt->hdr->data, buf, size);
+
+    return PLAYER_SUCCESS;
+}
+
+static int m4s2_dx50_mp4v_write_header(am_private_t *para, am_packet_t *pkt)
+{
+    CLog::Log(LOGDEBUG, "%s::%s m4s2_dx50_mp4v_write_header", CLASSNAME, __func__);
+
+    int ret = m4s2_dx50_mp4v_add_header(para->extradata, para->extrasize, pkt);
+    if (ret == PLAYER_SUCCESS) {
+        pkt->codec = &para->vcodec;
+        pkt->newflag = 1;
+        ret = write_av_packet(para, pkt);
+    }
+    return ret;
+}
+
+static int mpeg_add_header(am_private_t *para, am_packet_t *pkt)
+{
+    CLog::Log(LOGDEBUG, "%s::%s mpeg_add_header", CLASSNAME, __func__);
+
+#define STUFF_BYTES_LENGTH     (256)
+
+    int size;
+    unsigned char packet_wrapper[] = {
+        0x00, 0x00, 0x01, 0xe0,
+        0x00, 0x00,                                /* pes packet length */
+        0x81, 0xc0, 0x0d,
+        0x20, 0x00, 0x00, 0x00, 0x00, /* PTS */
+        0x1f, 0xff, 0xff, 0xff, 0xff, /* DTS */
+        0xff, 0xff, 0xff, 0xff, 0xff, 0xff
+    };
+
+    size = para->extrasize + sizeof(packet_wrapper);
+    packet_wrapper[4] = size >> 8 ;
+    packet_wrapper[5] = size & 0xff ;
+    memcpy(pkt->hdr->data, packet_wrapper, sizeof(packet_wrapper));
+    size = sizeof(packet_wrapper);
+    //CLog::Log(LOGDEBUG, "[mpeg_add_header:%d]wrapper size=%d\n",__LINE__,size);
+    memcpy(pkt->hdr->data + size, para->extradata, para->extrasize);
+    size += para->extrasize;
+    //CLog::Log(LOGDEBUG, "[mpeg_add_header:%d]wrapper+seq size=%d\n",__LINE__,size);
+    memset(pkt->hdr->data + size, 0xff, STUFF_BYTES_LENGTH);
+    size += STUFF_BYTES_LENGTH;
+    pkt->hdr->size = size;
+    //CLog::Log(LOGDEBUG, "[mpeg_add_header:%d]hdr_size=%d\n",__LINE__,size);
+
+    pkt->codec = &para->vcodec;
+    pkt->newflag = 1;
+    return write_av_packet(para, pkt);
+
+}
+
+int pre_header_feeding(am_private_t *para, am_packet_t *pkt)
+{
+    int ret;
+
+    if (pkt->hdr == NULL) {
+        pkt->hdr = (hdr_buf_t*)malloc(sizeof(hdr_buf_t));
+        pkt->hdr->data = (char*)malloc(HDR_BUF_SIZE);
+        if (!pkt->hdr->data) {
+            CLog::Log(LOGERROR, "%s::%s [pre_header_feeding] NOMEM!", CLASSNAME, __func__);
+            return PLAYER_NOMEM;
+        }
+    }
+
+    if (para->stream_type == AM_STREAM_ES) {
+        if (VFORMAT_H264 == para->video_format || VFORMAT_H264_4K2K == para->video_format) {
+            ret = h264_write_header(para, pkt);
+            if (ret != PLAYER_SUCCESS) {
+                return ret;
+            }
+        } else if (VFORMAT_HEVC == para->video_format) {
+            ret = hevc_write_header(para, pkt);
+            if (ret != PLAYER_SUCCESS) {
+                return ret;
+            }
+        } else if ((VFORMAT_MPEG4 == para->video_format) && (VIDEO_DEC_FORMAT_MPEG4_3 == para->video_codec_type)) {
+            ret = divx3_write_header(para, pkt);
+            if (ret != PLAYER_SUCCESS) {
+                return ret;
+            }
+        } else if ((CODEC_TAG_M4S2 == para->video_codec_tag)
+                || (CODEC_TAG_DX50 == para->video_codec_tag)
+                || (CODEC_TAG_mp4v == para->video_codec_tag)) {
+            ret = m4s2_dx50_mp4v_write_header(para, pkt);
+            if (ret != PLAYER_SUCCESS) {
+                return ret;
+            }
+        }
+    }
+    else if (para->stream_type == AM_STREAM_PS) {
+        if (( AV_CODEC_ID_MPEG1VIDEO == para->video_codec_id)
+          || (AV_CODEC_ID_MPEG2VIDEO == para->video_codec_id)) {
+            ret = mpeg_add_header(para, pkt);
+            if (ret != PLAYER_SUCCESS) {
+                return ret;
+            }
+        }
+    }
+
+    if (pkt->hdr) {
+        if (pkt->hdr->data) {
+            free(pkt->hdr->data);
+            pkt->hdr->data = NULL;
+        }
+        free(pkt->hdr);
+        pkt->hdr = NULL;
+    }
+
+    return PLAYER_SUCCESS;
+}
+
+CLinuxC1Codec::CLinuxC1Codec() {
+  am_private = new am_private_t;
+  memzero(*am_private);
+}
+
+CLinuxC1Codec::~CLinuxC1Codec() {
+  delete am_private;
+  am_private = NULL;
+}
+
+bool CLinuxC1Codec::OpenDecoder(CDVDStreamInfo &hints) {
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
+
+  m_speed = DVD_PLAYSPEED_NORMAL;
+  m_1st_pts = 0;
+  m_cur_pts = 0;
+  m_cur_pictcnt = 0;
+  m_old_pictcnt = 0;
+  m_start_dts = 0;
+  m_start_pts = 0;
+  m_hints = hints;
+
+  memzero(am_private->am_pkt);
+  am_private->stream_type      = AM_STREAM_ES;
+  am_private->video_width      = hints.width;
+  am_private->video_height     = hints.height;
+  am_private->video_codec_id   = hints.codec;
+  am_private->video_codec_tag  = hints.codec_tag;
+  am_private->video_pid        = hints.pid;
+
+  // handle video ratio
+  AVRational video_ratio       = av_d2q(1, SHRT_MAX);
+  am_private->video_ratio      = ((int32_t)video_ratio.num << 16) | video_ratio.den;
+  am_private->video_ratio64    = ((int64_t)video_ratio.num << 32) | video_ratio.den;
+
+  // handle video rate
+  if (hints.rfpsrate > 0 && hints.rfpsscale != 0)
+  {
+    // check ffmpeg r_frame_rate 1st
+    am_private->video_rate = 0.5 + (float)UNIT_FREQ * hints.rfpsscale / hints.rfpsrate;
+  }
+  else if (hints.fpsrate > 0 && hints.fpsscale != 0)
+  {
+    // then ffmpeg avg_frame_rate next
+    am_private->video_rate = 0.5 + (float)UNIT_FREQ * hints.fpsscale / hints.fpsrate;
+  }
+
+  // check for 1920x1080, interlaced, 25 fps
+  // incorrectly reported as 50 fps (yes, video_rate == 1920)
+  if (hints.width == 1920 && am_private->video_rate == 1920)
+  {
+    CLog::Log(LOGDEBUG, "%s::%s video_rate exception", CLASSNAME, __func__);
+    am_private->video_rate = 0.5 + (float)UNIT_FREQ * 1001 / 25000;
+  }
+
+  // check for SD h264 content incorrectly reported as 60 fsp
+  // mp4/avi containers :(
+  if (hints.codec == AV_CODEC_ID_H264 && hints.width <= 720 && am_private->video_rate == 1602)
+  {
+    CLog::Log(LOGDEBUG, "%s::%s video_rate exception", CLASSNAME, __func__);
+    am_private->video_rate = 0.5 + (float)UNIT_FREQ * 1001 / 24000;
+  }
+
+  // check for SD h264 content incorrectly reported as some form of 30 fsp
+  // mp4/avi containers :(
+  if (hints.codec == AV_CODEC_ID_H264 && hints.width <= 720)
+  {
+    if (am_private->video_rate >= 3200 && am_private->video_rate <= 3210)
+    {
+      CLog::Log(LOGDEBUG, "%s::%s video_rate exception", CLASSNAME, __func__);
+      am_private->video_rate = 0.5 + (float)UNIT_FREQ * 1001 / 24000;
+    }
+  }
+
+  // handle orientation
+  am_private->video_rotation_degree = 0;
+  if (hints.orientation == 90)
+    am_private->video_rotation_degree = 1;
+  else if (hints.orientation == 180)
+    am_private->video_rotation_degree = 2;
+  else if (hints.orientation == 270)
+    am_private->video_rotation_degree = 3;
+
+  // handle extradata
+  am_private->video_format      = codecid_to_vformat(hints.codec);
+  if (am_private->video_format == VFORMAT_H264) {
+    if (hints.width > 1920 || hints.height > 1088) {
+      am_private->video_format = VFORMAT_H264_4K2K;
+    }
+  }
+
+  am_private->extrasize       = hints.extrasize;
+  am_private->extradata       = (uint8_t*)malloc(hints.extrasize);
+  memcpy(am_private->extradata, hints.extradata, hints.extrasize);
+
+  if (am_private->stream_type == AM_STREAM_ES && am_private->video_codec_tag != 0)
+    am_private->video_codec_type = codec_tag_to_vdec_type(am_private->video_codec_tag);
+  if (am_private->video_codec_type == VIDEO_DEC_FORMAT_UNKNOW)
+    am_private->video_codec_type = codec_tag_to_vdec_type(am_private->video_codec_id);
+
+  am_private->flv_flag = 0;
+
+  CLog::Log(LOGDEBUG, "%s::%s hints.width(%d), hints.height(%d), hints.codec(%d), hints.codec_tag(%d), hints.pid(%d)",
+    CLASSNAME, __func__, hints.width, hints.height, hints.codec, hints.codec_tag, hints.pid);
+  CLog::Log(LOGDEBUG, "%s::%s hints.fpsrate(%d), hints.fpsscale(%d), hints.rfpsrate(%d), hints.rfpsscale(%d), video_rate(%d)",
+    CLASSNAME, __func__, hints.fpsrate, hints.fpsscale, hints.rfpsrate, hints.rfpsscale, am_private->video_rate);
+  CLog::Log(LOGDEBUG, "%s::%s hints.orientation(%d), hints.forced_aspect(%d), hints.extrasize(%d)",
+    CLASSNAME, __func__, hints.orientation, hints.forced_aspect, hints.extrasize);
+
+  // default video codec params
+  am_private->gcodec.noblock     = 0;
+  am_private->gcodec.video_pid   = am_private->video_pid;
+  am_private->gcodec.video_type  = am_private->video_format;
+  am_private->gcodec.stream_type = STREAM_TYPE_ES_VIDEO;
+  am_private->gcodec.format      = am_private->video_codec_type;
+  am_private->gcodec.width       = am_private->video_width;
+  am_private->gcodec.height      = am_private->video_height;
+  am_private->gcodec.rate        = am_private->video_rate;
+  am_private->gcodec.ratio       = am_private->video_ratio;
+  am_private->gcodec.ratio64     = am_private->video_ratio64;
+  am_private->gcodec.param       = NULL;
+
+  switch(am_private->video_format)
+  {
+    case VFORMAT_MPEG4:
+      am_private->gcodec.param = (void*)EXTERNAL_PTS;
+      break;
+    case VFORMAT_H264:
+    case VFORMAT_H264MVC:
+      am_private->gcodec.format = VIDEO_DEC_FORMAT_H264;
+      am_private->gcodec.param  = (void*)EXTERNAL_PTS;
+      // h264 in an avi file
+      if (m_hints.ptsinvalid)
+        am_private->gcodec.param = (void*)(EXTERNAL_PTS | SYNC_OUTSIDE);
+      break;
+    case VFORMAT_H264_4K2K:
+      am_private->gcodec.format = VIDEO_DEC_FORMAT_H264_4K2K;
+      am_private->gcodec.param  = (void*)EXTERNAL_PTS;
+      // h264 in an avi file
+      if (m_hints.ptsinvalid)
+        am_private->gcodec.param = (void*)(EXTERNAL_PTS | SYNC_OUTSIDE);
+      break;
+    case VFORMAT_HEVC:
+      am_private->gcodec.format = VIDEO_DEC_FORMAT_HEVC;
+      am_private->gcodec.param  = (void*)EXTERNAL_PTS;
+      if (m_hints.ptsinvalid)
+        am_private->gcodec.param = (void*)(EXTERNAL_PTS | SYNC_OUTSIDE);
+      break;
+    default:
+      break;
+  }
+  am_private->gcodec.param = (void *)((unsigned int)am_private->gcodec.param | (am_private->video_rotation_degree << 16));
+
+  // translate from generic to firmware version dependent
+  codec_init_para(&am_private->gcodec, &am_private->vcodec);
+
+  int ret = codec_init(&am_private->vcodec);
+  if (ret != CODEC_ERROR_NONE)
+  {
+    CLog::Log(LOGERROR, "%s::%s codec init failed, ret=0x%x", CLASSNAME, __func__, -ret);
+    return false;
+  }
+
+  // make sure we are not stuck in pause (amcodec bug)
+  codec_resume(&am_private->vcodec);
+  codec_set_cntl_mode(&am_private->vcodec, TRICKMODE_NONE);
+
+  codec_set_cntl_avthresh(&am_private->vcodec, AV_SYNC_THRESH);
+  codec_set_cntl_syncthresh(&am_private->vcodec, 0);
+  // disable tsync, we are playing video disconnected from audio.
+  SysfsUtils::SetInt("/sys/class/tsync/enable", 0);
+
+  am_private->am_pkt.codec = &am_private->vcodec;
+  pre_header_feeding(am_private, &am_private->am_pkt);
+
+  SetSpeed(m_speed);
+
+  SetViewport(hints.width, hints.height);
+  ShowMainVideo(true);
+
+  return true;
+}
+
+void CLinuxC1Codec::ShowMainVideo(const bool show)
+{
+  SysfsUtils::SetInt("/sys/class/video/disable_video", show ? 0 : 1);
+}
+
+void CLinuxC1Codec::SetSpeed(int speed)
+{
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
+
+  m_speed = speed;
+
+  switch(speed)
+  {
+    case DVD_PLAYSPEED_PAUSE:
+      codec_pause(&am_private->vcodec);
+      codec_set_cntl_mode(&am_private->vcodec, TRICKMODE_NONE);
+      break;
+    case DVD_PLAYSPEED_NORMAL:
+      codec_resume(&am_private->vcodec);
+      codec_set_cntl_mode(&am_private->vcodec, TRICKMODE_NONE);
+      break;
+    default:
+      codec_resume(&am_private->vcodec);
+      if ((am_private->video_format == VFORMAT_H264) || (am_private->video_format == VFORMAT_H264_4K2K))
+        codec_set_cntl_mode(&am_private->vcodec, TRICKMODE_FFFB);
+      else
+        codec_set_cntl_mode(&am_private->vcodec, TRICKMODE_I);
+      break;
+  }
+}
+
+bool CLinuxC1Codec::GetPicture(DVDVideoPicture *pDvdVideoPicture)
+{
+  debug_log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
+
+  pDvdVideoPicture->iDuration = (double)(am_private->video_rate * DVD_TIME_BASE) / UNIT_FREQ;
+
+  pDvdVideoPicture->dts = DVD_NOPTS_VALUE;
+  if (m_speed == DVD_PLAYSPEED_NORMAL)
+  {
+    pDvdVideoPicture->pts = GetPlayerPtsSeconds() * (double)DVD_TIME_BASE;
+    // video pts cannot be late or dvdplayer goes nuts,
+    // so run it one frame ahead
+    pDvdVideoPicture->pts += 1 * pDvdVideoPicture->iDuration;
+  }
+  else
+  {
+    // We are FF/RW; Do not use the Player clock or it just doesn't work
+    if (m_cur_pts == 0)
+      pDvdVideoPicture->pts = (double)m_1st_pts / PTS_FREQ * DVD_TIME_BASE;
+    else
+      pDvdVideoPicture->pts = (double)m_cur_pts / PTS_FREQ * DVD_TIME_BASE;
+  }
+
+  return true;
+}
+
+void CLinuxC1Codec::CloseDecoder() {
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
+
+  // never leave vcodec ff/rw or paused.
+  if (m_speed != DVD_PLAYSPEED_NORMAL)
+  {
+    codec_resume(&am_private->vcodec);
+    codec_set_cntl_mode(&am_private->vcodec, TRICKMODE_NONE);
+  }
+  codec_close(&am_private->vcodec);
+
+  am_packet_release(&am_private->am_pkt);
+  free(am_private->extradata);
+  am_private->extradata = NULL;
+  SysfsUtils::SetInt("/sys/class/tsync/enable", 1);
+
+  SetViewport(0, 0);
+  ShowMainVideo(false);
+  usleep(500 * 1000);
+}
+
+double CLinuxC1Codec::GetPlayerPtsSeconds()
+{
+  double clock_pts = 0.0;
+#ifndef THIS_IS_NOT_XBMC
+  CDVDClock *playerclock = CDVDClock::GetMasterClock();
+  if (playerclock)
+    clock_pts = playerclock->GetClock() / DVD_TIME_BASE;
+#endif
+  return clock_pts;
+}
+
+int CLinuxC1Codec::Decode(uint8_t *pData, size_t iSize, double dts, double pts) {
+  debug_log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
+
+  if (pData)
+  {
+    am_private->am_pkt.data = pData;
+    am_private->am_pkt.data_size = iSize;
+
+    am_private->am_pkt.newflag    = 1;
+    am_private->am_pkt.isvalid    = 1;
+    am_private->am_pkt.avduration = 0;
+
+    // handle pts, including 31bit wrap, aml can only handle 31
+    // bit pts as it uses an int in kernel.
+    if (m_hints.ptsinvalid || pts == DVD_NOPTS_VALUE)
+      am_private->am_pkt.avpts = AV_NOPTS_VALUE;
+    else
+    {
+      am_private->am_pkt.avpts = 0.5 + (pts * PTS_FREQ) / DVD_TIME_BASE;\
+      if (!m_start_pts && am_private->am_pkt.avpts >= 0x7fffffff)
+        m_start_pts = am_private->am_pkt.avpts & ~0x0000ffff;
+    }
+    if (am_private->am_pkt.avpts != (int64_t)AV_NOPTS_VALUE)
+      am_private->am_pkt.avpts -= m_start_pts;
+
+
+    // handle dts, including 31bit wrap, aml can only handle 31
+    // bit dts as it uses an int in kernel.
+    if (dts == DVD_NOPTS_VALUE)
+      am_private->am_pkt.avdts = AV_NOPTS_VALUE;
+    else
+    {
+      am_private->am_pkt.avdts = 0.5 + (dts * PTS_FREQ) / DVD_TIME_BASE;
+      if (!m_start_dts && am_private->am_pkt.avdts >= 0x7fffffff)
+        m_start_dts = am_private->am_pkt.avdts & ~0x0000ffff;
+    }
+    if (am_private->am_pkt.avdts != (int64_t)AV_NOPTS_VALUE)
+      am_private->am_pkt.avdts -= m_start_dts;
+
+    debug_log(LOGDEBUG, "%s::%s: iSize(%d), dts(%f), pts(%f), avdts(%llx), avpts(%llx)",
+      CLASSNAME, __func__, iSize, dts, pts, am_private->am_pkt.avdts, am_private->am_pkt.avpts);
+
+    while (am_private->am_pkt.isvalid)
+    {
+      // abort on any errors.
+      if (write_av_packet(am_private, &am_private->am_pkt) != PLAYER_SUCCESS)
+        break;
+
+      if (am_private->am_pkt.isvalid)
+        CLog::Log(LOGDEBUG, "%s::%s: write_av_packet looping", CLASSNAME, __func__);
+    }
+
+    // if we seek, then GetTimeSize is wrong as
+    // reports lastpts - cur_pts and hw decoder has
+    // not started outputing new pts values yet.
+    // so we grab the 1st pts sent into driver and
+    // use that to calc GetTimeSize.
+    if (m_1st_pts == 0)
+      m_1st_pts = am_private->am_pkt.lastpts;
+  }
+
+  int64_t pts_video = 0;
+  int rtn = VC_BUFFER;
+  pts_video = get_pts_video();
+  if (pts_video != m_cur_pts) {
+    m_cur_pts = pts_video;
+    m_cur_pictcnt++;
+    m_old_pictcnt++;
+    rtn |= VC_PICTURE;
+  }
+
+  debug_log(LOGDEBUG, "%s::%s rtn(%d), m_cur_pictcnt(%lld), m_cur_pts(%f), lastpts(%f)",
+    CLASSNAME, __func__, rtn, m_cur_pictcnt, (float)m_cur_pts/PTS_FREQ, (float)am_private->am_pkt.lastpts/PTS_FREQ);
+
+  return rtn;
+}
+
+void CLinuxC1Codec::Reset() {
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
+
+  int blackout_policy;
+  SysfsUtils::GetInt("/sys/class/video/blackout_policy", blackout_policy);
+  SysfsUtils::SetInt("/sys/class/video/blackout_policy", 0);
+
+  if (m_speed != DVD_PLAYSPEED_NORMAL)
+  {
+    codec_resume(&am_private->vcodec);
+    codec_set_cntl_mode(&am_private->vcodec, TRICKMODE_NONE);
+  }
+  codec_reset(&am_private->vcodec);
+
+  am_packet_release(&am_private->am_pkt);
+  memzero(am_private->am_pkt);
+  am_private->am_pkt.codec = &am_private->vcodec;
+  pre_header_feeding(am_private, &am_private->am_pkt);
+
+  SysfsUtils::SetInt("/sys/class/video/blackout_policy", blackout_policy);
+
+  m_1st_pts = 0;
+  m_cur_pts = 0;
+  m_cur_pictcnt = 0;
+  m_old_pictcnt = 0;
+  SetSpeed(m_speed);
+}
+
+void CLinuxC1Codec::SetViewport(int width, int height) {
+
+  if (m_hints.aspect > 0.0 && (((int)lrint(height * m_hints.aspect)) & -3) > width)
+    width = ((int)lrint(height * m_hints.aspect)) & -3;
+
+  char setting[256] = {};
+  double scale;
+  int displayWidth = CDisplaySettings::Get().GetCurrentResolutionInfo().iWidth;
+  int displayHeight = CDisplaySettings::Get().GetCurrentResolutionInfo().iHeight;
+  int cutWidth;
+  int cutHeight;
+
+  if (width > 0 && height > 0) {
+    scale = fmin((double)displayWidth / (double)width, (double)displayHeight / (double)height);
+    cutWidth = (displayWidth - (int)((double)width * scale)) / 2;
+    cutHeight = (displayHeight - (int)((double)height * scale)) / 2;
+    sprintf(setting, "%d %d %d %d", 0 + cutWidth, 0 + cutHeight, displayWidth - cutWidth, displayHeight - cutHeight);
+  } else {
+    sprintf(setting, "%d %d %d %d", 0, 0, 0, 0);
+  }
+
+  CLog::Log(LOGDEBUG, "%s::%s Setting viewport to %s", CLASSNAME, __func__, setting);
+  SysfsUtils::SetString("/sys/class/video/axis", setting);
+  SysfsUtils::SetInt("/sys/class/video/screen_mode", 1);
+}
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/LinuxC1Codec.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/LinuxC1Codec.h
new file mode 100644
index 0000000..f1a194c
--- /dev/null
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/LinuxC1Codec.h
@@ -0,0 +1,167 @@
+#pragma once
+
+#include <queue>
+#include <string>
+#include <math.h>
+#include <poll.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+  #include <amcodec/codec.h>
+  #include <amcodec/codec_type.h>
+#ifdef __cplusplus
+}
+#endif
+#include <adec-external-ctrl.h>
+
+#ifdef _DEBUG
+  #define debug_log(...) CLog::Log(__VA_ARGS__)
+#else
+  #define debug_log(...)
+#endif
+
+#ifndef THIS_IS_NOT_XBMC
+  #include "DVDVideoCodec.h"
+  #include "DVDClock.h"
+  #include "DVDStreamInfo.h"
+  #include "settings/DisplaySettings.h"
+  #include "utils/BitstreamConverter.h"
+  #include "utils/SysfsUtils.h"
+#else
+  #include "xbmcstubs.h"
+#endif
+
+#define memzero(x) memset(&(x), 0, sizeof (x))
+
+#define PTS_FREQ        90000
+#define UNIT_FREQ       96000
+#define AV_SYNC_THRESH  PTS_FREQ*30
+
+#define TRICKMODE_NONE  0x00
+#define TRICKMODE_I     0x01
+#define TRICKMODE_FFFB  0x02
+
+#define EXTERNAL_PTS    (1)
+#define SYNC_OUTSIDE    (2)
+
+#define HDR_BUF_SIZE 1024
+
+#define P_PRE                     (0x02000000)
+#define PLAYER_SUCCESS            (0)
+#define PLAYER_FAILED             (-(P_PRE|0x01))
+#define PLAYER_NOMEM              (-(P_PRE|0x02))
+#define PLAYER_EMPTY_P            (-(P_PRE|0x03))
+#define PLAYER_WR_FAILED          (-(P_PRE|0x21))
+#define PLAYER_WR_EMPTYP          (-(P_PRE|0x22))
+#define PLAYER_WR_FINISH          (P_PRE|0x1)
+#define PLAYER_PTS_ERROR          (-(P_PRE|0x31))
+#define PLAYER_UNSUPPORT          (-(P_PRE|0x35))
+#define PLAYER_CHECK_CODEC_ERROR  (-(P_PRE|0x39))
+
+#define RW_WAIT_TIME    (20 * 1000) // 20ms
+
+typedef struct hdr_buf {
+    char *data;
+    int size;
+} hdr_buf_t;
+
+typedef struct am_packet {
+    AVPacket      avpkt;
+    int64_t       avpts;
+    int64_t       avdts;
+    int           avduration;
+    int           isvalid;
+    int           newflag;
+    int64_t       lastpts;
+    unsigned char *data;
+    unsigned char *buf;
+    int           data_size;
+    int           buf_size;
+    hdr_buf_t     *hdr;
+    codec_para_t  *codec;
+} am_packet_t;
+
+typedef enum {
+    AM_STREAM_UNKNOWN = 0,
+    AM_STREAM_TS,
+    AM_STREAM_PS,
+    AM_STREAM_ES,
+    AM_STREAM_RM,
+    AM_STREAM_AUDIO,
+    AM_STREAM_VIDEO,
+} pstream_type;
+
+typedef struct {
+  bool          noblock;
+  int           video_pid;
+  int           video_type;
+  stream_type_t stream_type;
+  unsigned int  format;
+  unsigned int  width;
+  unsigned int  height;
+  unsigned int  rate;
+  unsigned int  extra;
+  unsigned int  status;
+  unsigned int  ratio;
+  unsigned long long ratio64;
+  void *param;
+} aml_generic_param;
+
+typedef struct am_private_t
+{
+  am_packet_t       am_pkt;
+  aml_generic_param gcodec;
+  codec_para_t      vcodec;
+
+  pstream_type      stream_type;
+  int               check_first_pts;
+
+  vformat_t         video_format;
+  int               video_pid;
+  unsigned int      video_codec_id;
+  unsigned int      video_codec_tag;
+  vdec_type_t       video_codec_type;
+  unsigned int      video_width;
+  unsigned int      video_height;
+  unsigned int      video_ratio;
+  unsigned int      video_ratio64;
+  unsigned int      video_rate;
+  unsigned int      video_rotation_degree;
+  int               flv_flag;
+  int               h263_decodable;
+  int               extrasize;
+  uint8_t           *extradata;
+
+  int               dumpfile;
+  bool              dumpdemux;
+} am_private_t;
+
+class CLinuxC1Codec
+{
+public:
+  CLinuxC1Codec();
+  ~CLinuxC1Codec();
+
+  bool             OpenDecoder(CDVDStreamInfo &hints);
+  void             CloseDecoder();
+  int              Decode(uint8_t *pData, size_t size, double dts, double pts);
+  bool             GetPicture(DVDVideoPicture *pDvdVideoPicture);
+  void             Reset();
+  void             SetSpeed(int speed);
+
+private:
+  volatile int     m_speed;
+  CDVDStreamInfo   m_hints;
+  am_private_t    *am_private;
+  volatile int64_t m_1st_pts;
+  volatile int64_t m_cur_pts;
+  volatile int64_t m_cur_pictcnt;
+  volatile int64_t m_old_pictcnt;
+  int64_t          m_start_dts;
+  int64_t          m_start_pts;
+
+  void             SetViewport(int width, int height);
+  double           GetPlayerPtsSeconds();
+  void             ShowMainVideo(const bool show);
+};
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in b/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in
index 56ec6a3..611fadd 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in
@@ -41,6 +41,11 @@ ifeq (@USE_MMAL@,1)
 SRCS += MMALCodec.cpp
 endif
 
+ifeq (@USE_C1@,1)
+SRCS += LinuxC1Codec.cpp
+SRCS += DVDVideoCodecC1.cpp
+endif
+
 LIB=Video.a
 
 include @abs_top_srcdir@/Makefile.include
diff --git a/xbmc/utils/AMLUtils.cpp b/xbmc/utils/AMLUtils.cpp
index bcb57fc..0a27ef7 100644
--- a/xbmc/utils/AMLUtils.cpp
+++ b/xbmc/utils/AMLUtils.cpp
@@ -174,7 +174,8 @@ enum AML_DEVICE_TYPE aml_get_device_type()
         aml_device_type = AML_DEVICE_TYPE_M8M2;
       else
         aml_device_type = AML_DEVICE_TYPE_M8;
-    } else if (cpu_hardware.find("Meson8B") != std::string::npos)
+    } else if (cpu_hardware.find("Meson8B") != std::string::npos
+            || cpu_hardware.find("ODROID") != std::string::npos)
       aml_device_type = AML_DEVICE_TYPE_M8B;
     else
       aml_device_type = AML_DEVICE_TYPE_UNKNOWN;
@@ -242,7 +243,7 @@ void aml_probe_hdmi_audio()
   {
     char valstr[1024] = {0};
 
-    read(fd, valstr, sizeof(valstr) - 1);
+    int ret = read(fd, valstr, sizeof(valstr) - 1);
     valstr[strlen(valstr)] = '\0';
     close(fd);
 
@@ -329,16 +330,52 @@ bool aml_mode_to_resolution(const char *mode, RESOLUTION_INFO *res)
     res->fRefreshRate = 60;
     res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
   }
-  else if (StringUtils::EqualsNoCase(fromMode, "720p"))
+  else if (StringUtils::EqualsNoCase(fromMode, "720p23hz")) // fake
   {
     res->iWidth = 1280;
     res->iHeight= 720;
     res->iScreenWidth = 1280;
     res->iScreenHeight= 720;
-    res->fRefreshRate = 60;
+    res->fRefreshRate = 23.98;
+    res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
+  }
+  else if (StringUtils::EqualsNoCase(fromMode, "720p24hz")) // fake
+  {
+    res->iWidth = 1280;
+    res->iHeight= 720;
+    res->iScreenWidth = 1280;
+    res->iScreenHeight= 720;
+    res->fRefreshRate = 24;
+    res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
+  }
+  else if (StringUtils::EqualsNoCase(fromMode, "720p25hz")) // fake
+  {
+    res->iWidth = 1280;
+    res->iHeight= 720;
+    res->iScreenWidth = 1280;
+    res->iScreenHeight= 720;
+    res->fRefreshRate = 25;
+    res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
+  }
+  else if (StringUtils::EqualsNoCase(fromMode, "720p29hz")) // fake
+  {
+    res->iWidth = 1280;
+    res->iHeight= 720;
+    res->iScreenWidth = 1280;
+    res->iScreenHeight= 720;
+    res->fRefreshRate = 29.97;
+    res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
+  }
+  else if (StringUtils::EqualsNoCase(fromMode, "720p30hz")) // fake
+  {
+    res->iWidth = 1280;
+    res->iHeight= 720;
+    res->iScreenWidth = 1280;
+    res->iScreenHeight= 720;
+    res->fRefreshRate = 30;
     res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
   }
-  else if (StringUtils::EqualsNoCase(fromMode, "720p50hz"))
+  else if (StringUtils::EqualsNoCase(fromMode, "720p50hz")) // real
   {
     res->iWidth = 1280;
     res->iHeight= 720;
@@ -347,16 +384,34 @@ bool aml_mode_to_resolution(const char *mode, RESOLUTION_INFO *res)
     res->fRefreshRate = 50;
     res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
   }
-  else if (StringUtils::EqualsNoCase(fromMode, "1080p"))
+  else if (StringUtils::EqualsNoCase(fromMode, "720p59hz")) // real
+  {
+    res->iWidth = 1280;
+    res->iHeight= 720;
+    res->iScreenWidth = 1280;
+    res->iScreenHeight= 720;
+    res->fRefreshRate = 59.94;
+    res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
+  }
+  else if (StringUtils::EqualsNoCase(fromMode, "720p")) // real
+  {
+    res->iWidth = 1280;
+    res->iHeight= 720;
+    res->iScreenWidth = 1280;
+    res->iScreenHeight= 720;
+    res->fRefreshRate = 60;
+    res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
+  }
+  else if (StringUtils::EqualsNoCase(fromMode, "1080p23hz")) // real
   {
     res->iWidth = 1920;
     res->iHeight= 1080;
     res->iScreenWidth = 1920;
     res->iScreenHeight= 1080;
-    res->fRefreshRate = 60;
+    res->fRefreshRate = 23.98;
     res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
   }
-  else if (StringUtils::EqualsNoCase(fromMode, "1080p24hz"))
+  else if (StringUtils::EqualsNoCase(fromMode, "1080p24hz")) // real
   {
     res->iWidth = 1920;
     res->iHeight= 1080;
@@ -365,7 +420,25 @@ bool aml_mode_to_resolution(const char *mode, RESOLUTION_INFO *res)
     res->fRefreshRate = 24;
     res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
   }
-  else if (StringUtils::EqualsNoCase(fromMode, "1080p30hz"))
+  else if (StringUtils::EqualsNoCase(fromMode, "1080p25hz")) // fake
+  {
+    res->iWidth = 1920;
+    res->iHeight= 1080;
+    res->iScreenWidth = 1920;
+    res->iScreenHeight= 1080;
+    res->fRefreshRate = 25;
+    res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
+  }
+  else if (StringUtils::EqualsNoCase(fromMode, "1080p29hz")) // fake
+  {
+    res->iWidth = 1920;
+    res->iHeight= 1080;
+    res->iScreenWidth = 1920;
+    res->iScreenHeight= 1080;
+    res->fRefreshRate = 29.97;
+    res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
+  }
+  else if (StringUtils::EqualsNoCase(fromMode, "1080p30hz")) // fake
   {
     res->iWidth = 1920;
     res->iHeight= 1080;
@@ -374,7 +447,7 @@ bool aml_mode_to_resolution(const char *mode, RESOLUTION_INFO *res)
     res->fRefreshRate = 30;
     res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
   }
-  else if (StringUtils::EqualsNoCase(fromMode, "1080p50hz"))
+  else if (StringUtils::EqualsNoCase(fromMode, "1080p50hz")) // real
   {
     res->iWidth = 1920;
     res->iHeight= 1080;
@@ -383,14 +456,23 @@ bool aml_mode_to_resolution(const char *mode, RESOLUTION_INFO *res)
     res->fRefreshRate = 50;
     res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
   }
-  else if (StringUtils::EqualsNoCase(fromMode, "1080i"))
+  else if (StringUtils::EqualsNoCase(fromMode, "1080p59hz")) // real
+  {
+    res->iWidth = 1920;
+    res->iHeight= 1080;
+    res->iScreenWidth = 1920;
+    res->iScreenHeight= 1080;
+    res->fRefreshRate = 59.94;
+    res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
+  }
+  else if (StringUtils::EqualsNoCase(fromMode, "1080p")) // real
   {
     res->iWidth = 1920;
     res->iHeight= 1080;
     res->iScreenWidth = 1920;
     res->iScreenHeight= 1080;
     res->fRefreshRate = 60;
-    res->dwFlags = D3DPRESENTFLAG_INTERLACED;
+    res->dwFlags = D3DPRESENTFLAG_PROGRESSIVE;
   }
   else if (StringUtils::EqualsNoCase(fromMode, "1080i50hz"))
   {
@@ -401,6 +483,24 @@ bool aml_mode_to_resolution(const char *mode, RESOLUTION_INFO *res)
     res->fRefreshRate = 50;
     res->dwFlags = D3DPRESENTFLAG_INTERLACED;
   }
+  else if (StringUtils::EqualsNoCase(fromMode, "1080i59hz"))
+  {
+    res->iWidth = 1920;
+    res->iHeight= 1080;
+    res->iScreenWidth = 1920;
+    res->iScreenHeight= 1080;
+    res->fRefreshRate = 59.94;
+    res->dwFlags = D3DPRESENTFLAG_INTERLACED;
+  }
+  else if (StringUtils::EqualsNoCase(fromMode, "1080i"))
+  {
+    res->iWidth = 1920;
+    res->iHeight= 1080;
+    res->iScreenWidth = 1920;
+    res->iScreenHeight= 1080;
+    res->fRefreshRate = 60;
+    res->dwFlags = D3DPRESENTFLAG_INTERLACED;
+  }
   else if (StringUtils::EqualsNoCase(fromMode, "4k2ksmpte"))
   {
     res->iWidth = 1920;
diff --git a/xbmc/windowing/egl/EGLNativeTypeAmlogic.cpp b/xbmc/windowing/egl/EGLNativeTypeAmlogic.cpp
index f2073cb..fb7f744 100644
--- a/xbmc/windowing/egl/EGLNativeTypeAmlogic.cpp
+++ b/xbmc/windowing/egl/EGLNativeTypeAmlogic.cpp
@@ -23,13 +23,18 @@
 #include "utils/AMLUtils.h"
 #include "utils/StringUtils.h"
 #include "utils/SysfsUtils.h"
+#include "utils/log.h"
 
-#include <stdio.h>
 #include <stdlib.h>
 #include <linux/fb.h>
 #include <sys/ioctl.h>
 #include <EGL/egl.h>
 
+#ifdef CLASSNAME
+#undef CLASSNAME
+#endif
+#define CLASSNAME "CEGLNativeTypeAmlogic"
+
 CEGLNativeTypeAmlogic::CEGLNativeTypeAmlogic()
 {
   const char *env_framebuffer = getenv("FRAMEBUFFER");
@@ -66,6 +71,7 @@ void CEGLNativeTypeAmlogic::Initialize()
   aml_permissions();
   aml_cpufreq_min(true);
   aml_cpufreq_max(true);
+  FreeScale(false);
   return;
 }
 void CEGLNativeTypeAmlogic::Destroy()
@@ -77,20 +83,26 @@ void CEGLNativeTypeAmlogic::Destroy()
 
 bool CEGLNativeTypeAmlogic::CreateNativeDisplay()
 {
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
   m_nativeDisplay = EGL_DEFAULT_DISPLAY;
   return true;
 }
 
 bool CEGLNativeTypeAmlogic::CreateNativeWindow()
 {
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
 #if defined(_FBDEV_WINDOW_H_)
   fbdev_window *nativeWindow = new fbdev_window;
   if (!nativeWindow)
     return false;
 
-  nativeWindow->width = 1280;
-  nativeWindow->height = 720;
+  RESOLUTION_INFO res;
+  GetPreferredResolution(&res);
+
+  nativeWindow->width = res.iWidth;
+  nativeWindow->height = res.iHeight;
   m_nativeWindow = nativeWindow;
+
   return true;
 #else
   return false;
@@ -99,6 +111,7 @@ bool CEGLNativeTypeAmlogic::CreateNativeWindow()
 
 bool CEGLNativeTypeAmlogic::GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const
 {
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
   if (!nativeDisplay)
     return false;
   *nativeDisplay = (XBNativeDisplayType*) &m_nativeDisplay;
@@ -107,6 +120,7 @@ bool CEGLNativeTypeAmlogic::GetNativeDisplay(XBNativeDisplayType **nativeDisplay
 
 bool CEGLNativeTypeAmlogic::GetNativeWindow(XBNativeWindowType **nativeWindow) const
 {
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
   if (!nativeWindow)
     return false;
   *nativeWindow = (XBNativeWindowType*) &m_nativeWindow;
@@ -115,11 +129,13 @@ bool CEGLNativeTypeAmlogic::GetNativeWindow(XBNativeWindowType **nativeWindow) c
 
 bool CEGLNativeTypeAmlogic::DestroyNativeDisplay()
 {
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
   return true;
 }
 
 bool CEGLNativeTypeAmlogic::DestroyNativeWindow()
 {
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
 #if defined(_FBDEV_WINDOW_H_)
   delete (fbdev_window*)m_nativeWindow, m_nativeWindow = NULL;
 #endif
@@ -135,55 +151,137 @@ bool CEGLNativeTypeAmlogic::GetNativeResolution(RESOLUTION_INFO *res) const
 
 bool CEGLNativeTypeAmlogic::SetNativeResolution(const RESOLUTION_INFO &res)
 {
-  switch((int)(0.5 + res.fRefreshRate))
+  CLog::Log(LOGNOTICE, "%s::%s to %dx%d@%f", CLASSNAME, __func__, res.iScreenWidth, res.iScreenHeight, res.fRefreshRate);
+
+  bool result = false;
+
+  switch((int)res.fRefreshRate) // floor the resolution, so 23.98 will be brought down to 23
   {
-    default:
-    case 60:
+    case 23:
+      switch(res.iScreenWidth)
+      {
+        case 1920:
+          result = SetDisplayResolution("1080p23hz");
+          break;
+      }
+      break;
+    case 24:
+      switch(res.iScreenWidth)
+      {
+        case 1920:
+          result = SetDisplayResolution("1080p24hz");
+          break;
+      }
+      break;
+    case 25:
+    case 50:
       switch(res.iScreenWidth)
       {
-        default:
         case 1280:
-          SetDisplayResolution("720p");
+          result = SetDisplayResolution("720p50hz");
           break;
         case 1920:
           if (res.dwFlags & D3DPRESENTFLAG_INTERLACED)
-            SetDisplayResolution("1080i");
+            result = SetDisplayResolution("1080i50hz");
           else
-            SetDisplayResolution("1080p");
+            result = SetDisplayResolution("1080p50hz");
           break;
       }
       break;
-    case 50:
+    case 29:
+    case 59:
       switch(res.iScreenWidth)
       {
-        default:
         case 1280:
-          SetDisplayResolution("720p50hz");
+          result = SetDisplayResolution("720p59hz");
           break;
         case 1920:
           if (res.dwFlags & D3DPRESENTFLAG_INTERLACED)
-            SetDisplayResolution("1080i50hz");
+            result = SetDisplayResolution("1080i59hz");
           else
-            SetDisplayResolution("1080p50hz");
+            result = SetDisplayResolution("1080p59hz");
           break;
       }
       break;
     case 30:
-      SetDisplayResolution("1080p30hz");
-      break;
-    case 24:
-      SetDisplayResolution("1080p24hz");
+    case 60:
+      switch(res.iScreenWidth)
+      {
+        case 1280:
+          result = SetDisplayResolution("720p");
+          break;
+        case 1920:
+          if (res.dwFlags & D3DPRESENTFLAG_INTERLACED)
+            result = SetDisplayResolution("1080i");
+          else
+            result = SetDisplayResolution("1080p");
+          break;
+      }
       break;
   }
 
+  return result;
+}
+
+bool CEGLNativeTypeAmlogic::SetDisplayResolution(const char *resolution)
+{
+  CLog::Log(LOGNOTICE, "%s::%s to %s", CLASSNAME, __func__, resolution);
+  std::string mode = resolution;
+  // switch display resolution
+  SysfsUtils::SetString("/sys/class/display/mode", mode.c_str());
+
+  RESOLUTION_INFO res;
+  if(aml_mode_to_resolution(mode.c_str(), &res)) {
+    CLog::Log(LOGDEBUG, "%s::%s to %dx%d", CLASSNAME, __func__, res.iWidth, res.iHeight);
+    int fd0;
+    std::string framebuffer = "/dev/" + m_framebuffer_name;
+
+    if ((fd0 = open(framebuffer.c_str(), O_RDWR)) >= 0)
+    {
+      struct fb_var_screeninfo vinfo;
+      if (ioctl(fd0, FBIOGET_VSCREENINFO, &vinfo) == 0)
+      {
+         vinfo.xres = res.iWidth;
+         vinfo.yres = res.iHeight;
+         vinfo.xres_virtual = vinfo.xres;
+         vinfo.yres_virtual = vinfo.yres*2;
+         vinfo.bits_per_pixel = 32;
+         vinfo.activate = FB_ACTIVATE_ALL;
+         ioctl(fd0, FBIOPUT_VSCREENINFO, &vinfo);
+      }
+      close(fd0);
+    }
+  }
+
   return true;
 }
 
 bool CEGLNativeTypeAmlogic::ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions)
 {
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
   std::string valstr;
   SysfsUtils::GetString("/sys/class/amhdmitx/amhdmitx0/disp_cap", valstr);
-  std::vector<std::string> probe_str = StringUtils::Split(valstr, "\n");
+
+  std::vector<std::string> probe_str;
+  probe_str.push_back("720p23hz");  // fake
+  probe_str.push_back("720p24hz");  // fake
+  probe_str.push_back("720p25hz");  // fake
+  probe_str.push_back("720p29hz");  // fake
+  probe_str.push_back("720p30hz");  // fake
+  probe_str.push_back("720p50hz");  // real
+  probe_str.push_back("720p59hz");  // real
+  probe_str.push_back("720p");      // real
+  probe_str.push_back("1080p23hz"); // real
+  probe_str.push_back("1080p24hz"); // real
+  probe_str.push_back("1080p25hz"); // fake
+  probe_str.push_back("1080p29hz"); // fake
+  probe_str.push_back("1080p30hz"); // fake
+  probe_str.push_back("1080p50hz"); // real
+  probe_str.push_back("1080p59hz"); // real
+  probe_str.push_back("1080p");     // real
+  probe_str.push_back("1080i50hz"); // real
+  probe_str.push_back("1080i59hz"); // real
+  probe_str.push_back("1080i");     // real
 
   resolutions.clear();
   RESOLUTION_INFO res;
@@ -193,11 +291,11 @@ bool CEGLNativeTypeAmlogic::ProbeResolutions(std::vector<RESOLUTION_INFO> &resol
       resolutions.push_back(res);
   }
   return resolutions.size() > 0;
-
 }
 
 bool CEGLNativeTypeAmlogic::GetPreferredResolution(RESOLUTION_INFO *res) const
 {
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
   // check display/mode, it gets defaulted at boot
   if (!GetNativeResolution(res))
   {
@@ -210,98 +308,26 @@ bool CEGLNativeTypeAmlogic::GetPreferredResolution(RESOLUTION_INFO *res) const
 
 bool CEGLNativeTypeAmlogic::ShowWindow(bool show)
 {
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
   std::string blank_framebuffer = "/sys/class/graphics/" + m_framebuffer_name + "/blank";
   SysfsUtils::SetInt(blank_framebuffer.c_str(), show ? 0 : 1);
   return true;
 }
 
-bool CEGLNativeTypeAmlogic::SetDisplayResolution(const char *resolution)
-{
-  std::string mode = resolution;
-  // switch display resolution
-  SysfsUtils::SetString("/sys/class/display/mode", mode.c_str());
-  SetupVideoScaling(mode.c_str());
-
-  return true;
-}
-
-void CEGLNativeTypeAmlogic::SetupVideoScaling(const char *mode)
+void CEGLNativeTypeAmlogic::FreeScale(bool state)
 {
-  SysfsUtils::SetInt("/sys/class/graphics/fb0/blank",      1);
-  SysfsUtils::SetInt("/sys/class/graphics/fb0/free_scale", 0);
-  SysfsUtils::SetInt("/sys/class/graphics/fb1/free_scale", 0);
-  SysfsUtils::SetInt("/sys/class/ppmgr/ppscaler",          0);
-
-  if (strstr(mode, "1080"))
-  {
-    SysfsUtils::SetString("/sys/class/graphics/fb0/request2XScale", "8");
-    SysfsUtils::SetString("/sys/class/graphics/fb1/scale_axis",     "1280 720 1920 1080");
-    SysfsUtils::SetString("/sys/class/graphics/fb1/scale",          "0x10001");
-  }
-  else
-  {
-    SysfsUtils::SetString("/sys/class/graphics/fb0/request2XScale", "16 1280 720");
-  }
-
-  SysfsUtils::SetInt("/sys/class/graphics/fb0/blank", 0);
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
+  std::string freescale_framebuffer = "/sys/class/graphics/" + m_framebuffer_name + "/free_scale";
+  SysfsUtils::SetInt(freescale_framebuffer.c_str(), state ? 1 : 0);
 }
 
-void CEGLNativeTypeAmlogic::EnableFreeScale()
+bool CEGLNativeTypeAmlogic::IsHdmiConnected() const
 {
-  // enable OSD free scale using frame buffer size of 720p
-  SysfsUtils::SetInt("/sys/class/graphics/fb0/free_scale", 0);
-  SysfsUtils::SetInt("/sys/class/graphics/fb1/free_scale", 0);
-  SysfsUtils::SetInt("/sys/class/graphics/fb0/scale_width",  1280);
-  SysfsUtils::SetInt("/sys/class/graphics/fb0/scale_height", 720);
-  SysfsUtils::SetInt("/sys/class/graphics/fb1/scale_width",  1280);
-  SysfsUtils::SetInt("/sys/class/graphics/fb1/scale_height", 720);
-
-  // enable video free scale (scaling to 1920x1080 with frame buffer size 1280x720)
-  SysfsUtils::SetInt("/sys/class/ppmgr/ppscaler", 0);
-  SysfsUtils::SetInt("/sys/class/video/disable_video", 1);
-  SysfsUtils::SetInt("/sys/class/ppmgr/ppscaler", 1);
-  SysfsUtils::SetString("/sys/class/ppmgr/ppscaler_rect", "0 0 1919 1079 0");
-  SysfsUtils::SetString("/sys/class/ppmgr/disp", "1280 720");
-  //
-  SysfsUtils::SetInt("/sys/class/graphics/fb0/scale_width",  1280);
-  SysfsUtils::SetInt("/sys/class/graphics/fb0/scale_height", 720);
-  SysfsUtils::SetInt("/sys/class/graphics/fb1/scale_width",  1280);
-  SysfsUtils::SetInt("/sys/class/graphics/fb1/scale_height", 720);
-  //
-  SysfsUtils::SetInt("/sys/class/video/disable_video", 2);
-  SysfsUtils::SetString("/sys/class/display/axis", "0 0 1279 719 0 0 0 0");
-  SysfsUtils::SetString("/sys/class/ppmgr/ppscaler_rect", "0 0 1279 719 1");
-  //
-  SysfsUtils::SetInt("/sys/class/graphics/fb0/free_scale", 1);
-  SysfsUtils::SetInt("/sys/class/graphics/fb1/free_scale", 1);
-  SysfsUtils::SetString("/sys/class/graphics/fb0/free_scale_axis", "0 0 1279 719");
-}
-
-void CEGLNativeTypeAmlogic::DisableFreeScale()
-{
-  // turn off frame buffer freescale
-  SysfsUtils::SetInt("/sys/class/graphics/fb0/free_scale", 0);
-  SysfsUtils::SetInt("/sys/class/graphics/fb1/free_scale", 0);
-  SysfsUtils::SetString("/sys/class/graphics/fb0/free_scale_axis", "0 0 1279 719");
-
-  SysfsUtils::SetInt("/sys/class/ppmgr/ppscaler", 0);
-  SysfsUtils::SetInt("/sys/class/video/disable_video", 0);
-  // now default video display to off
-  SysfsUtils::SetInt("/sys/class/video/disable_video", 1);
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
 
-  // revert display axis
-  int fd0;
-  std::string framebuffer = "/dev/" + m_framebuffer_name;
+  std::string hpd_state;
+  SysfsUtils::GetString("/sys/class/amhdmitx/amhdmitx0/disp_cap", hpd_state);
+  StringUtils::Trim(hpd_state);
+  return hpd_state == "1";
 
-  if ((fd0 = open(framebuffer.c_str(), O_RDWR)) >= 0)
-  {
-    struct fb_var_screeninfo vinfo;
-    if (ioctl(fd0, FBIOGET_VSCREENINFO, &vinfo) == 0)
-    {
-      char daxis_str[256] = {0};
-      sprintf(daxis_str, "%d %d %d %d 0 0 0 0", 0, 0, vinfo.xres-1, vinfo.yres-1);
-      SysfsUtils::SetString("/sys/class/display/axis", daxis_str);
-    }
-    close(fd0);
-  }
 }
diff --git a/xbmc/windowing/egl/EGLNativeTypeAmlogic.h b/xbmc/windowing/egl/EGLNativeTypeAmlogic.h
index cc34ff7..782db38 100644
--- a/xbmc/windowing/egl/EGLNativeTypeAmlogic.h
+++ b/xbmc/windowing/egl/EGLNativeTypeAmlogic.h
@@ -49,10 +62,9 @@ public:
 
 protected:
   bool SetDisplayResolution(const char *resolution);
-  void SetupVideoScaling(const char *mode);
-  void EnableFreeScale();
-  void DisableFreeScale();
 
 private:
   std::string m_framebuffer_name;
+  void FreeScale(bool state);
+  bool IsHdmiConnected() const;
 };
